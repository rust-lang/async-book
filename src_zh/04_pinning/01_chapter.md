# 固定（Pinning）

为了轮询future，future首先要用特殊类型`Pin<T>`来固定。如果你读了前面《执行`Future`与
任务小节中关于`Future`退出的解释，你会从`Future::poll`方法的定义中认出`Pin`。但这意味
什么？我们为什么需要它？

## 为什么需要固定

固定保证对象永不移动。为了理解这为什么必须，我们回忆一下`async`/`.await`怎么工作吧。
考虑以下代码：

```rust,no_run
let fut_one = ...;
let fut_two = ...;
async move {
    fut_one.await;
    fut_two.await;
}
```

这段代码实际上创建了一个实现了`Future`特质的匿名类型，提供了`poll`方法，如下：

```rust,no_run
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```

当`poll`第一次调用时，它会轮询`fut_one`。如果`fut_one`不能完成，那么
`AsyncFuture::poll`就会返回。调用`poll`的Future会从上次中断的地方继续。这个过程会持续
到future成功完成。

然而，如果我们在`async`块中用了引用呢？例如：

```rust,no_run
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

这会编译成什么结构呢？

```rust
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

这里，`ReadIhtoBuf`future持有了一个指向其他字段`x`的引用。然而，如果`AsyncFuture`被
移动了，`x`的位置（location）也会被移走，使得存储在`read_into_buf_fut.buf`的指针失效。

固定future到内存特定位置则阻止了这种问题，让创建指向`async`块的引用变得安全。

## 如何固定？

`Pin`类型包装了指针类型，保证了指针指向的值不会被移走。例如，`Pin<&mut T>`，`Pin<&T>`
和`Pin<Box<T>>`全都保证了`T`不会被移走。

多数类型被移走也不会有问题。这些类型实现了`Unpin`特质。指向`Unpin`类型的指针能够自由地
放进`Pin`，或取走。例如，`u8`是`Unpin`的，所以`Pin<&mut T>`的行为就像普通的`&mut T`。

一些函数需要他们协作的future是`Unpin`的。为了让这些函数使用不是`Unpin`的`Future`或
`Stream`，你首先需要这个值固定，要么用`Box::pin`（创建`Pin<Box<T>>`）要么使用
`pin_utils::pin_mut!`（创建`Pin<&mut T>`）。`Pin<Box<Fut>>`和`Pin<&mut Fut>`都能
用作future，并且都实现了`Unpin`。

例如：

```rust,no_run
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { ... }

let fut = async { ... };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { ... };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { ... };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

["Executing `Future`s and Tasks"]: ../02_execution/01_chapter.md
[the `Future` trait]: ../02_execution/02_future.md
