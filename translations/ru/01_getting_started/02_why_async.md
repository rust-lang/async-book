# Для чего нужна асинхронность?

Все мы любим то, что Rust позволяет нам писать быстрые и безопасные
приложения. Но для чего писать асинхронный код?

Асинхронный код позволяет нам запускать несколько задач
параллельно в одном потоке ОС. Если вы в обычном приложении
хотите одновременно загрузить две разных web-страницы, вы
должны разделить работу между двумя разным потоками, как тут:

```rust
{{#include ../../../examples/01_02_why_async/src/lib.rs:get_two_sites}}
```

Для многих приложений это замечательно работает - в конце концов,
потоки были разработаны именно для этого: одновременно
запускать несколько разных задач. Однако, они имеют некоторые
ограничения. В процессе переключения между разными потоками и
обменом данными между ними возникает много накладных расходов.
Даже поток, который сидит и ничего не делает, использует ценные
системные ресурсы. Асинхронный код предназначен для устранения
этих проблем. Мы можем переписать функции выше используя
нотацию `async`/`.await`, которая позволяет
нам запустить несколько задач одновременно, не создавая нескольких потоков:

```rust
{{#include ../../../examples/01_02_why_async/src/lib.rs:get_two_sites_async}}
```

В целом, асинхронные приложения могут быть намного быстрее и
использовать меньше ресурсов, чем соответствующая
многопоточная реализация. Однако, есть и обратная сторона.
Потоки изначально поддерживаются операционной системой и их
использование не требует какой-либо специальной модели
программирования - любая функция может создать поток и вызов
функции, использующей потоки, обычно так же прост, как вызов
обычной функции. Тем не менее, асинхронные функции требуют
специальной поддержки со стороны языка или библиотек. В Rust,
`async fn` создаёт асинхронную функцию, которая
возвращает `Future`. Для выполнения тела функции,
возвращённая `Future` должна быть завершена.

Важно помнить, что традиционные приложения с потоками могут
быть вполне эффективными и предсказуемость Rust и небольшой
объём используемой памяти могут значить, что вы можете далеко
продвинуться и без использования `async`.
Повышенная сложность асинхронной модели программирования
не всегда стоит этого и важно понимать, когда ваше приложение
будет лучше работать с использованием простой поточной модели.
