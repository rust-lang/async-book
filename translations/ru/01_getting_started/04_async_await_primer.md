# Пример `async`/`.await`

`async`/`.await` - это встроенные в Rust
инструменты для написания асинхронного кода, который выглядит
как синхронный код. Ключевое слово `async` преобразует блок кода в конечный
автомат, который реализует типаж, называемый `Future`. В то  время как вызов
блокирующей функции в синхронном методе заблокирует весь поток, заблокированная
`Future` вернёт контроль над потоком, позволяя работать другим `Future`.

Для создания асинхронной функции, вы можете использовать
синтаксис `async fn`:

```rust
async fn do_something() { ... }
```

Значение, возвращённое`async fn` является `Future`. Что бы ни произошло,
`Future` должна быть запущена в исполнителе.

```rust
{{#include ../../../examples/01_04_async_await_primer/src/lib.rs:hello_world}}
```

Внутри `async fn` можно использовать
`.await` для ожидания завершения другого типа,
реализующего типаж `Future` (например, полученного из другой `async fn`).
В отличие от `block_on`, `.await` не блокирует текущий поток, но асинхронно ждёт
завершения футуры, позволяя другим задачам выполняться, если в данный момент
футура не может добиться прогресса.

Например, представим что у нас есть три синхронный функции `async fn`:
`learn_song`, `sing_song` и `dance`:

```rust
async fn learn_song() -> Song { ... }
async fn sing_song(song: Song) { ... }
async fn dance() { ... }
```

Одним из способов выполнения функций учить, петь и танцевать будет остановка на
каждом из них:

```rust
{{#include ../../../examples/01_04_async_await_primer/src/lib.rs:block_on_each}}
```

Тем не менее, в этом случае мы не получаем наилучшей
производительности - в один момент мы делаем только одно дело!
Очевидно, что мы должны выучить песню до того, как петь её, но
мы можем танцевать в то же время, пока учим песню и поём её.
Чтобы сделать это, мы создадим две отдельные `async fn`, которые могут
запуститься параллельно:

```rust
{{#include ../../../examples/01_04_async_await_primer/src/lib.rs:block_on_main}}
```

В этом примере, изучение песни должно быть завершено до пения, но и изучение и
пение могут завершиться одновременно с танцем. Если мы использовали бы
`block_on(learn_song())` вместо `learn_song().await` внутри `learn_and_sing`,
поток не смог бы делать ничего другого, пока работает `learn_song`. Из-за этого
мы одновременно с этим не можем танцевать.
С помощью ожидания `.await` футуры `learn_song`, мы разрешаем другим задачам
захватить текущий поток, пока `learn_song` заблокирована. Это делает возможным
запуск нескольких футур, завершающихся параллельно в одном потоке.

Теперь мы изучили основы `async`/`.await`, давайте посмотрим их в действии.
