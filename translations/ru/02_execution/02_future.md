# Типаж `Future`

Типаж `Future` является центральным для асинхронного
программирования в Rust. `Future` - это асинхронное
вычисление, которое может производить значение (хотя значение
может быть и пустым, например `()`).
*Упрощённый* вариант этого типажа может выглядеть как-то
так:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:simple_future}}
```

Футуры могут прогрессировать при помощи функции
`poll`, которая продвигает их к завершению на сколько
это возможно. Если футура завершается, она возвращает
`Poll::Ready(result)`. Если же она всё ещё не готова
завершиться, то - `Poll::Pending` и обрабатывает
функцию `wake()` таким образом, что она будет вызвана, когда
`Future` будет готова прогрессировать. Когда
`wake()` вызван, исполнитель снова вызывает у
`Future` метод `poll`, чтобы она смогла
продвинуться далее.

Без `wake()`, исполнитель не имеет возможности узнать,
когда какая-либо футура может продвинуться, и ему необходимо
постоянно опрашивать каждую футуру. С `wake()` он точно
знает какие футуры готовы прогрессировать.

Например, представим ситуацию, когда мы хотим прочитать из сокета, который может
иметь, а может и не иметь данных. Если данные есть, мы можем прочитать их и
вернуть `Poll::Ready(data)`, но если данных ещё нет, наша футура блокируется и
не может продвинуться дальше. Если данных нет, то мы должны зарегистрировать
вызов `wake`, чтобы он был вызван, когда данные появятся в сокете, и сообщил
нашему исполнителю, что футура готова прогрессировать. Простая футура
`SocketRead` может выглядеть следующим образом:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:socket_read}}
```

Такая модель футур позволяет держать вместе несколько
асинхронных операций без лишних промежуточных выделений памяти.
Одновременный запуск нескольких футур или соединение их в
цепочку может быть реализовано при помощи не выделяющей
памяти машины состояний, например так:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:join}}
```

Здесь показано, как несколько футур могут быть запущены
одновременно без необходимости раздельной аллокации, позволяя
асинхронным программам быть более эффективными. Аналогично,
несколько последовательных футур могут быть запущены одна за
другой, как тут:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:and_then}}
```

Этот пример показывает, как типаж `Future` может
использоваться для выражения асинхронного управления потоком
без необходимости множественной аллокации объектов и глубоко
вложенных замыканий. Давайте оставим базовое управление
потоком в стороне и поговорим о реальном типаже
`Future` и чем он отличается от написанного нами.

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:real_future}}
```

Первое, что вы могли заметить, что наш тип `self`
больше не `&mut self`, а заменён на
`Pin<&mut Self>`. Мы поговорим о
закреплении (pinning) [в следующей секции], но пока что знайте, что
оно позволяет нам создавать неперемещаемые футуры.
Неперемещаемые объекты могут хранить указатели на
собственные поля, например
`struct MyFut { a: i32, ptr_to_a: *const i32 }`.
Закрепление необходимо для `async`/`await`.

Второе, `wake: fn()` была изменена на
`&mut Context<'_>`. В
`SimpleFuture` мы использовали вызов указателя на
функцию (`fn()`), чтобы сказать исполнителю, что
футура должна быть опрошена. Однако, так как `fn()`
имеет нулевой тип, она не может сохранить информацию о том
_какая_ футура вызвала `wake`.

В примере из реального мира, сложное приложение, такое как web-сервер,
может иметь тысячи различных подключений все пробуждения
которых должны обрабатываться отдельно. Тип
`Context` решает это предоставляя доступ к значению
типа `Waker`, который может быть использован для
пробуждения конкретной задачи.


[в следующей секции]: ../04_pinning/01_chapter.md
