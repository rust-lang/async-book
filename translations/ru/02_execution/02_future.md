# Типаж `Future`

Типаж `Future` является центральным для асинхронного
программирования в Rust. `Future` - это асинхронное
вычисление, которое может производить значение (хотя значение
может быть и пустым, например `()`).
*Упрощённый* вариант этого типажа может выглядеть как-то
так:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:simple_future}}
```

Футуры могут быть продвинуты(?) при помощи функции
`poll`, которая продвигает их так далеко, на сколько
это возможно. Если футура завершается, она возвращает
`Poll::Ready(result)`. Если же она до сих пор не готова
завершиться, то - `Poll::Pending` и предоставляет
функцию `wake()`, которая будет вызвана, когда
`Future` будет готова совершить прогресс(?). Когда
`wake()` вызван, исполнитель снова вызывает у
`Future` метод `poll`, чтобы она смогла
продвинуться(?).

Без `wake()`, исполнитель не имеет возможности узнать,
когда какая-либо `future` может продвинуться, и был бы должен
постоянно опрашивать каждую `future`. С `wake()` точно
знает какие `future`s можно опросить.

Например, представим ситуацию, когда мы хотим прочитать из сокета, который может иметь, а может и не иметь данных. Если данные есть, мы можем прочитать их и вернуть `Poll::Ready(data)`, но если данных ещё нет, наша `future` блокируется и не может прогрессировать. Когда данных нет, мы должны зарегистрировать вызов `wake`, когда данные появятся в сокете

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:socket_read}}
```

Такая модель `future` позволяет держать вместе несколько
асинхронных операций без лишних промежуточных выделений памяти.
Одновременный запуск нескольких `future`s или соединение их в
цепочку может быть реализовано при помощи машины состояний,
не делающий выделений памяти, например так:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:join}}
```

Здесь показано, как несколько футур могут быть запущены
одновременно без необходимости раздельной аллокации, позволяя
асинхронным программам быть более эффективными. Аналогично,
несколько последовательных футур могут быть запущены одна за
другой, как тут:

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:and_then}}
```

Этот пример показывает, как типаж `Future` может
использоваться для выражения асинхронного управления потоком
без необходимости множественной аллокации объектов и глубоко
вложенных замыканий. Оставим базовое управление потоком в
стороне и давайте поговорим о реальном типаже
`Future` и чем он отличается.

```rust
{{#include ../../../examples/02_02_future_trait/src/lib.rs:real_future}}
```

Первое, что вы могли заметить, что наш тип `self`
больше не `&mut self`, а заменён на
`Pin<&mut Self>`. Мы поговорим о
закреплении [в следующей секции](../04_pinning/01_chapter.md), но пока что знайте, что
оно позволяет нам создавать неперемещаемые `future`s.
Неперемещаемые объекты могут сохранять указатели на
собственные поля, например
`struct MyFut { a: i32, ptr_to_a: *const i32 }`.
Прикрепление необходимо для `async`/`await`.

Второе, `wake: fn()` была изменена на
`&mut Context<'_>`. В
`SimpleFuture` мы использовали вызов указателя на
функцию (`fn()`) чтобы сказать исполнителю, что
`future` должна быть опрошена. Однако, так как `fn()`
имеют нулевой тип, они не могут сохранить информацию о том
*какая* `future` вызвала `wake`.

В примере из реального мира, сложное приложение, как web-сервер
может иметь тысячи различных подключений, все пробуждения
которых должны обрабатываться отдельно. Тип
`Context` решает это предоставляя доступ к значению
типа `Waker`, который может быть использован для
пробуждения конкретной задачи.
