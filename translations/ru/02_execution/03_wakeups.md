# Вызовы задачи при помощи `Waker`

Обычно футуры не могут разрешиться сразу же, как для них
вызвали метод `poll`. Когда это произойдёт, футура
должна быть уверена, что её снова опросят, когда она будет готова
прогрессировать. Это решается при помощи типа `Waker`.

Футура опрашивается как часть "задачи" каждый раз, когда
происходит её опрос. Задачи - это высокоуровневые футуры, с
которыми работает исполнитель.

`Waker` предоставляет метод `wake()`,
который может быть использован, чтобы сказать исполнителю, что
соответствующая задача должна быть пробуждена. Когда
вызывается `wake()`, исполнитель
знает, что задача, связанная с `Waker`, готова к
выполнению, и её футура должна быть опрошена снова.

`Waker` так же реализует `clone()`, так
что вы можете его копировать, где это необходимо, и хранить.

Давайте попробуем реализовать простой таймер с использованием `Waker`.

## Применение: Создание таймера

В качестве примера, мы просто раскручиваем новый поток при
создании таймера, спим в течение необходимого времени, а затем
через какое-то время сообщаем о том, что заданный временной
промежуток истёк.

Вот список импортов, которые нам понадобятся:

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:imports}}
```

Начнём с определения типа футуры. Нашей футуре необходим
канал связи, чтобы сообщить о том, что время таймера истекло и
футура должна завершиться. В качестве канала связи между
таймером и футурой мы будем использовать разделяемое
значение `Arc<Mutex<..>>`.

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:timer_decl}}
```

Теперь давайте реализуем `Future` для нашей футуры!

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:future_for_timer}}
```

Просто, не так ли? Если поток установит `shared_state.completed = true`, мы
закончили! В противном случае мы клонируем `Waker` для
текущей задачи и сохраняем его в `shared_state.waker`.
Так поток может разбудить задачу позже.

Важно отметить, что мы должны обновлять `Waker`
каждый раз, когда футура опрашивается, потому что она может
быть перемещена в другую задачу с другим `Waker`.
Это может произойти когда футуры после опроса передаются
между задачами.

Наконец, нам нужен API, чтобы фактически построить таймер и
запустить поток:

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:timer_new}}
```

Это всё, что нам нужно, чтобы построить простую футуру
таймером. Теперь нам нужен исполнитель, чтобы запустить её на
исполнение.
