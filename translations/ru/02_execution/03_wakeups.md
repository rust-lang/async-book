# Вызовы задачи при помощи `Waker`

Обычно футуры не могут завершиться сразу же, как их опросили
(вызвали метод `poll`). Когда это случается, футура
должна быть уверена, что, когда она будет готова прогрессировать,
она будет снова опрошена. Это решается при помощи типа
`Waker`.

Каждый раз, когда футура опрашивается, она бывает частью
"задачи". Задачи - это высокоуровневые футуры, с которыми
работает исполнитель.

`Waker` обеспечивает метод `wake()`, который может быть использован, чтобы сказать исполнителю, что
соответствующая задача должна быть пробуждена. Когда вызывается `wake()`, исполнитель
знает, что задача, связанная с `Waker`, готова к выполнению, и
в будущем должна быть опрошена снова.

`Waker` так же реализует `clone()`. Так вы можете его копировать где необходимо и хранить.

Давайте попробуем реализовать простой таймер с использованием `Waker`.

## Применение: Создание таймера

В качестве примера, мы просто раскручиваем новый поток при создании таймера, спим в течение необходимого времени, а затем сообщаем о том когда время таймера истечёт.

Вот список зависимостей, которые нам понадобятся для начала:

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:imports}}
```

Давайте определим тип нашей `future`. Нашей `future` необходим канал связи, чтобы сообщить о том что время таймера истекло и `future` должна завершиться.
В качестве канала связи между таймером и `future` мы будем использовать разделяемое значение `Arc<Mutex<..>>`.

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:timer_decl}}
```

Теперь давайте напишем реализацию `Future`!

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:future_for_timer}}
```

Просто, не так ли? Если поток установит `shared_state.completed = true`, мы закончили! В противном случае мы клонируем `Waker` для текущей задачи и сохраняем его в `shared_state.waker`. Так поток может разбудить задачу позже.

Важно отметить, что мы должны обновлять `Waker` каждый раз, когда `future` опрашивается, потому что `future` может быть перемещена в другую задачу с другим `Waker`.
Это может произойти когда футуры передаются между задачами после опроса.

Наконец, нам нужен API, чтобы фактически построить таймер и запустить поток:

```rust
{{#include ../../../examples/02_03_timer/src/lib.rs:timer_new}}
```

Это всё, что нам нужно для того, чтобы построить простой таймер на `future`. Теперь нам нужен исполнитель, чтобы запустить `future` на исполнение.
