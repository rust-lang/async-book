# Применение: создание исполнителя

Футуры Rust'a ленивы: они ничего не будут делать, если не будут активно
доводиться до завершения. Один из способов довести их до завершения - это
`.await` внутри `async` функции, но это просто подталкивает проблему на один
уровень вверх: кто будет запускать футуры, возвращённые из `async` функций
верхнего уровня? Ответ в том, что нам нужен исполнитель для `Future`.

Исполнители берут набор футур верхнего уровня и запускают их через вызов метода
`poll`, до тех пор, пока они не завершатся. Как правило, исполнитель будет
вызывать метод `poll` у футуры один раз, чтобы запустить. Когда футура сообщает,
что готова продолжить вычисления и нужно вызвать метод `wake()`, она помещается
обратно в очередь и затем снова выполняется вызов `poll`. Это повторяется до тех
пор, пока `Future` не будет завершена.

В этом разделе мы напишем нашего собственного простого исполнителя, способного
одновременно запускать большое количество футур верхнего уровня.

Для этого примера мы используем пакет `futures`, в котором определён типаж
`ArcWake`. Данный типаж предоставляет простой способ создания `Waker`.

```toml
[package]
name = "xyz"
version = "0.1.0"
authors = ["XYZ Author"]
edition = "2018"

[dependencies]
futures-preview = "=0.3.0-alpha.17"
```

Дальше, мы должны в верхней части `src/main.rs` импортировать следующее:

```rust
{{#include ../../../examples/02_04_executor/src/lib.rs:imports}}
```

Наш исполнитель будет работать, посылая задачи для запуска по каналу.
Исполнитель извлечёт события из канала и запустит их. Когда задача будет готова
выполнить больше работы (будет пробуждена), она может запланировать повторный
опрос самой себя, отправив себя обратно в канал.

В этом проекте самому исполнителю просто необходим получатель для канала задачи.
Пользователь получит экземпляр отправителя, чтобы он мог создавать новые футуры.
Сами задачи - это просто футуры, которые могут перезапланировать самих себя,
поэтому мы сохраним их как сочетание футуры и отправителя, который задача может
использовать, чтобы добавить себя в очередь.

```rust
{{#include ../../../examples/02_04_executor/src/lib.rs:executor_decl}}
```

Давайте добавим к `Spawner` метод, облегчающий создание футур. Этот метод
возьмёт футуру, упакует и поместит её в `FutureObj` и создаст новый `Arc<Task>`
с полученным объектом внутри. Созданный `Arc<Task>` может быть поставлен в
очередь исполнителя.

```rust
{{#include ../../../examples/02_04_executor/src/lib.rs:spawn_fn}}
```

Чтобы опросить футуры, нам нужно создать `Waker`.
Как описано [в главе о пробуждении задач], `Waker` отвечает за планирование
задач, которые будут повторно опрошены после вызова `wake`. `Waker` сообщают
исполнителю, какая именно задача завершилась, позволяя опрашивать только те
футуры, которые готовы к продолжению выполнения. Наипростейший способ
создания нового `Waker` заключается в реализации типажа `ArcWake` и последующем
использовании функций `waker_ref` или `.into_waker()` для преобразования
`Arc<impl ArcWake>` в `Waker`. Давайте реализуем `ArcWake` для наших задач,
чтобы они могли превращаться в `Waker` и могли пробуждаться:

```rust
{{#include ../../../examples/02_04_executor/src/lib.rs:arcwake_for_task}}
```

Когда `Waker` создаётся на основе `Arc<Task>`, вызов `wake()` для него приведёт
к отправке копии `Arc` в канал задач. Тогда нашему исполнителю
нужно подобрать задание и опросить его. Давайте реализуем это:

```rust
{{#include ../../../examples/02_04_executor/src/lib.rs:executor_run}}
```

Поздравляю! Теперь у нас есть работающий исполнитель. Мы даже можем использовать
его для запуска `async/.await` кода и пользовательских футур, таких как
`TimerFuture`, которую мы написали ранее:

```rust
{{#include ../../../examples/02_04_executor/src/lib.rs:main}}
```


[в главе о пробуждении задач]: ./03_wakeups.md
