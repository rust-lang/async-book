# `join!`

Макрос `futures::join` позволяет дождаться завершения нескольких разных
футур при одновременном их выполнении.

# `join!`

При выполнении нескольких асинхронных операций возникает соблазн просто
последовательно вызвать несколько `.await`:

```rust
{{#include ../../../examples/06_02_join/src/lib.rs:naiive}}
```

Однако это будет медленнее, чем необходимо, так как он не начнёт пытаться выполнять
`get_music` до завершения `get_book`. В некоторых других языках,
футуры выполняются до завершения, поэтому две операции могут быть запущены
одновременно сначала вызовом каждой `async fn`, для запуска футур, а потом их ожиданием:

```rust
{{#include ../../../examples/06_02_join/src/lib.rs:other_langs}}
```

Однако футуры на Rust не будут работать, пока для них не будет вызван `.await`.
Это означает, что оба приведённых выше фрагмента кода запустят
`book_future` и `music_future` последовательно, вместо того, чтобы запустить их
параллельно. Чтобы правильно распараллелить их выполнение, используйте
`futures::join!`:

```rust
{{#include ../../../examples/06_02_join/src/lib.rs:join}}
```

Значение, возвращаемое `join!` - это кортеж, содержащий выходные данные каждой
из переданных `Future`.

## `try_join!`

Для футур, которые возвращают `Result`, может использоваться `try_join!`, а не
`join!`. Так как `join!` завершается только после завершения всех подфутур,
он будет продолжать обрабатывать другие футуры даже после того, как одна из
подфутур вернёт `Err`.

В отличие от`join!`, `try_join!` завершится
немедленно, если какая-либо из подфутур вернёт ошибку.

```rust
{{#include ../../../examples/06_02_join/src/lib.rs:try_join}}
```

Обратите внимание, что все футуры, переданные в `try_join!`, должны иметь один и тот же тип ошибки.
Рассмотрите возможность использования функций `.map_err(|e| ...)` и `.err_into()` из
`futures::future::TryFutureExt` для приведения типов ошибок к единому виду:

```rust
{{#include ../../../examples/06_02_join/src/lib.rs:try_join_map_err}}
```
