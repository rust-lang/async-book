# `select!`

Макрос `futures::select` запускает несколько `future`
одновременно, позволяя пользователю ответить как только любая
из `future` завершится.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:example}}
```

Функция выше запустит обе `t1` и `t2`
параллельно. Когда `t1` или `t2`
закончится, соответствующий дескриптор вызовет
`println!` и функция завершится без выполнения
оставшейся задачи.

Базовый синтаксис для `select`: `<pattern> = <expression> => <code>,`,
повторяемый столько раз, из скольких `future` вам надо сделать `select`.

## `default => ...` и `complete => ...`

Также `select` поддерживает ветки `default` и `complete`.

Ветка `default` выполнится, если ни одна из `future`,
переданная в `select`, не завершится. Поэтому,
`select` с веткой `default`, всегда будет
незамедлительно завершаться, так как `default` будет
запущена, когда ещё ни одна `future` не готова.

Ветка `complete` может быть использована для
обработки случая, когда все `futures`, бывшие в
`select`, завершились и уже не могут прогрессировать
дальше. Это бывает удобно, при использовании `select!` в цикле.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:default_and_complete}}
```

## Взаимодействие с `Unpin` и `FusedFuture`

Одна вещь, на которую вы могли обратить внимание в первом
примере, это то, что мы вызвали `.fuse()` на `futures`,
возвращённых из двух `async fn`, а потом закрепили
их с помощью `pin_mut`. Оба этих вызова важны,
потому что `future`, используемая в `select`, должна
реализовывать и типаж `Unpin`, и типаж
`FusedFuture`.

`Unpin` важен по той причине, что `future`, используемые в `select`, берутся не по значению, а по изменяемой ссылке. Так как владение `future` никому не передано, незавершённые `futures` могут быть снова использованы после вызова `select`.

Аналогично, типаж `FusedFuture` необходим, так как `select` не должен опрашивать `future` после их
завершения. `FusedFuture` реализуется `future`, которые отслеживают, завершены ли они или нет. Это делает
возможным использование `select` в цикле, опрашивая только `future`, которые до сих пор не завершились.
Это можно увидеть в примере выше, где `a_fut` или `b_fut` будут завершены во второй раз за цикл. Так
как `future`, возвращённая `future::ready`, реализует `FusedFuture`, она может сообщить
`select`, что её не надо снова опрашивать.

Заметьте, что у `stream` есть соответствующий типаж `FusedStream`. `Stream`, реализующие этот типаж
или имеющие обёртку, созданную `.fuse()`, возвращают `FusedFuture` из их комбинаторов
`.next()` и `.try_next()`.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:fused_stream}}
```

## Распараллеливание задач в цикле с `select` с помощью `Fuse` и `FuturesUnordered`

Одна довольно труднодоступная, но удобная функция - `Fuse::terminated()`, которая позволяет создавать уже
прекращённые пустые `future`, которые в последствии могут быть заполнены другой `future`, которую надо запустить.

Это может быть удобно, когда есть задача, которую надо запустить в цикле в `select`, но которая
создана вне этого цикла.

Обратите внимание на функцию `.select_next_some()`. Она может использоваться с `select` для запуска тех
ветвей, которые получили от потока `Some(_)`, а не `None`.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:fuse_terminated}}
```

Когда надо одновременно запустить много копий какой-либо `future`, используйте тип `FuturesUnordered`.
Следующий пример похож на один из тех, что выше, но дождётся завершения каждой выполненной копии
`run_on_new_num_fut`, а не остановит её при создании новой. Она также отобразит значение, возвращённое
`run_on_new_num_fut`.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:futures_unordered}}
```
