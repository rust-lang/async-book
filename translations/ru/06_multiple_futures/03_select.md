# `select!`

Макрос `futures::select` запускает несколько футур
одновременно и передаёт управление пользователю, как только любая из футур завершится.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:example}}
```

Функция выше запустит обе `t1` и `t2`
параллельно. Когда `t1` или `t2`
закончится, соответствующий дескриптор вызовет
`println!` и функция завершится без выполнения
оставшейся задачи.

Базовый синтаксис для `select`: `<pattern> = <expression> => <code>,`,
повторяемый столько раз, из скольких футур вам надо сделать `select`.

## `default => ...` и `complete => ...`

Также `select` поддерживает ветки `default` и `complete`.

Ветка `default` выполнится, если ни одна из футур,
переданных в `select`, не завершится. Поэтому
`select` с веткой `default` всегда будет
незамедлительно завершаться, так как `default` будет
запущен, когда ещё ни одна футура не готова.

Ветка `complete` может быть использована для
обработки случая, когда все футуры, бывшие в
`select`, завершились и уже не могут прогрессировать. Это бывает удобно, когда
`select!` используется в цикле.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:default_and_complete}}
```

## Взаимодействие с `Unpin` и `FusedFuture`

Одна вещь, на которую вы могли обратить внимание в первом
примере, это то, что мы вызвали `.fuse()` для футур,
возвращённых из двух `async fn`, а потом закрепили
их с помощью `pin_mut`. Оба этих вызова важны,
потому что футуры, используемые в `select`, должны
реализовывать и типаж `Unpin`, и типаж
`FusedFuture`.

`Unpin` важен по той причине, что футуры, используемые в `select`, берутся не по
значению, а по изменяемой ссылке. Так как владение футурами никому не передано,
незавершённые футуры могут быть снова использованы после вызова `select`.

Аналогично, типаж `FusedFuture` необходим, так как `select` не должен опрашивать футуры после их
завершения. `FusedFuture` реализуется футурами, которые отслеживают, завершены ли они или нет. Это делает
возможным использование `select` в цикле, опрашивая только те футуры, которые до сих пор не завершились.
Это можно увидеть в примере выше, где `a_fut` или `b_fut` будут завершены во второй раз за цикл. Так
как футура, возвращённая `future::ready`, реализует `FusedFuture`, она может сообщить
`select`, что её не надо снова опросить.

Заметьте, что у стримов есть соответствующий типаж `FusedStream`. Стримы, реализующие этот типаж
или имеющие обёртку, созданную `.fuse()`, возвращают `FusedFuture` из комбинаторов
`.next()` и `.try_next()`.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:fused_stream}}
```

## Распараллеливание задач в цикле с `select` с помощью `Fuse` и `FuturesUnordered`

Одна довольно труднодоступная, но удобная функция - `Fuse::terminated()`, которая позволяет создавать уже
прекращённые пустые футуры, которые в последствии могут быть заполнены другой футурой, которую надо запустить.

Это может быть удобно, когда есть задача, которую надо запустить в цикле в `select`, но которая
создана вне этого цикла.

Обратите внимание на функцию `.select_next_some()`. Она может использоваться с
`select` для запуска полученных из стрима тех ветвей, которые имеют значение
`Some(_)`, а не `None`.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:fuse_terminated}}
```

Когда надо одновременно запустить много копий какой-либо футуры, используйте тип `FuturesUnordered`.
Следующий пример похож на один из тех, что был выше, но здесь мы дожидаемся завершения каждой выполненной копии
`run_on_new_num_fut`, а не останавливаем её при создании новой. Он также отобразит значение, возвращённое
`run_on_new_num_fut`.

```rust
{{#include ../../../examples/06_03_select/src/lib.rs:futures_unordered}}
```
